% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/DRMatrix-class.R
\docType{class}
\name{DRMatrix}
\alias{DRMatrix}
\alias{DRMatrix-class}
\alias{[,DRMatrix,ANY-method}
\alias{[<-,DRMatrix,ANY,ANY,ANY-method}
\alias{cbind,DRMatrix-method}
\alias{dim,DRMatrix-method}
\alias{dimnames,DRMatrix-method}
\alias{dimnames<-,DRMatrix,NULL-method}
\alias{dimnames<-,DRMatrix,list-method}
\alias{length,DRMatrix-method}
\alias{nslice,DRMatrix-method}
\alias{rbind,DRMatrix-method}
\alias{slicenames,DRMatrix-method}
\alias{slicenames<-,DRMatrix,NULL-method}
\alias{slicenames<-,DRMatrix,character-method}
\title{Duplicate row matrices}
\usage{
DRMatrix(x, ...)

\S4method{dim}{DRMatrix}(x)

\S4method{nslice}{DRMatrix}(x)

\S4method{length}{DRMatrix}(x)

\S4method{dimnames}{DRMatrix}(x)

\S4method{slicenames}{DRMatrix}(x)

\S4method{dimnames}{DRMatrix,`NULL`}(x) <- value

\S4method{dimnames}{DRMatrix,list}(x) <- value

\S4method{slicenames}{DRMatrix,`NULL`}(x) <- value

\S4method{slicenames}{DRMatrix,character}(x) <- value

\S4method{[}{DRMatrix,ANY}(x, i, j, k, ..., drop = FALSE)

\S4method{[}{DRMatrix,ANY,ANY,ANY}(x, i, j, k, ...) <- value

\S4method{rbind}{DRMatrix}(..., deparse.level = 1)

\S4method{cbind}{DRMatrix}(..., deparse.level = 1)
}
\arguments{
\item{x}{A \link{DRMatrix} object.}
}
\description{
The \code{DRMatrix} class provides compressed storage of numeric matrices
with many duplicate rows. A basic matrix-like API is provided for
instantiating, subsetting, and combining DRMatrix objects.
}
\details{
Given a numeric \link[base]{matrix}, \code{x}, the DRMatrix representation
of \code{x}, \code{drm}, stores the \emph{unique} rows of \code{x} as a
\link{matrix} (\code{slot(drm, "key")}) and an integer column vector
(\code{slot(drm, "val")}) mapping each row of \code{x} to a row in
\code{slot(drm, "val")}. This means that \code{slot(drm, "map")} is a
permutation of \eqn{[1, \ldots} \code{nrow(x)} \eqn{]} and \code{nrow(val)}
\eqn{\le} \code{nrow(x)}. This representation is similar to an associative
array, hence the use of the slot names \code{key} and \code{val}.

A DRmatrix representation of \code{x} is only worthwhile if
\code{x} contains many duplicate rows since this ensures
that \code{nrow(val)} is much smaller than \code{nrow(x)}. This is
especially efficient if many of these rows are \code{NA} since these rows
need not be explicitly stored in \code{slot(drm, "val")}. Furthermore, the
DRMatrix representation of \code{x} becomes proportionally more efficient as
\code{ncol(x)} increases. \strong{TODO:
explicit formula for decrease in memory as a function of \code{nrow{x}},
\code{ncol(x)}, and \code{sum(duplicated(x))}}

A single DRMatrix object can in fact store data from multiple matrices,
\code{x1}, ..., \code{xn} provided that each matrix has the same dimensions
(\code{dim(x1) == ... == dim(xn)}). The \code{slot(drm, "key")} is then an
integer matrix where the columns index the input matrices \code{x1} through
\code{xn}. The \code{slot(drm, "val")} remains a single numeric
\link{matrix}, meaning that the memory efficiency increases with the number
of rows that are duplicated across \code{x1}, ..., \code{xn}.
}
\section{Slots}{

\describe{
\item{\code{key}}{An integer matrix with \code{nrow} equal to the number of rows in
the non-sparse version of the data and \code{ncol} equal to the number of
samples. The \eqn{(i, j)}-entry of the \code{key} corresponds to the
\eqn{i^{th}} row of the input matrix for the \eqn{j^{th}} sample.}

\item{\code{val}}{A numeric matrix storing the unique rows of input matrix/matrices.}
}}
\seealso{
\code{\link{DRMatrix}}
}

