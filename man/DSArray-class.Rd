% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DSArray-class.R
\docType{class}
\name{DSArray-class}
\alias{DSArray-class}
\alias{[,DSArray,ANY-method}
\alias{[<-,DSArray,ANY,ANY,DSArray-method}
\alias{acbind,DSArray-method}
\alias{arbind,DSArray-method}
\alias{densify,DSArray-method}
\alias{dim,DSArray-method}
\alias{dimnames,DSArray-method}
\alias{dimnames<-,DSArray,NULL-method}
\alias{dimnames<-,DSArray,list-method}
\alias{length,DSArray-method}
\alias{nslice,DSArray-method}
\alias{show,DSArray-method}
\alias{slicenames,DSArray-method}
\alias{slicenames<-,DSArray,NULL-method}
\alias{slicenames<-,DSArray,character-method}
\title{Duplicate slice arrays}
\usage{
\S4method{dim}{DSArray}(x)

\S4method{nslice}{DSArray}(x)

\S4method{length}{DSArray}(x)

\S4method{dimnames}{DSArray}(x)

\S4method{slicenames}{DSArray}(x)

\S4method{dimnames}{DSArray,`NULL`}(x) <- value

\S4method{dimnames}{DSArray,list}(x) <- value

\S4method{slicenames}{DSArray,`NULL`}(x) <- value

\S4method{slicenames}{DSArray,character}(x) <- value

\S4method{[}{DSArray,ANY}(x, i, j, k, ..., drop = FALSE)

\S4method{[}{DSArray,ANY,ANY,DSArray}(x, i, j, k, ...) <- value

\S4method{arbind}{DSArray}(...)

\S4method{acbind}{DSArray}(...)

\S4method{densify}{DSArray}(x)

\S4method{show}{DSArray}(object)
}
\arguments{
\item{x, object, value}{A \linkS4class{DSArray} object}

\item{i, j, k}{Indices specifying elements to extract or replace. Indices are
\code{numeric} or \code{character} vectors or empty (missing). \code{i}
indexes rows, \code{j} indexes columns, and \code{k} indexes slices.
\code{i}, \code{j}, and \code{k} can be logical vectors, indicating
elements/slices to select. Such vectors are recycled if necessary to match
the corresponding extent. Indexing by negative values, matrix \code{i}, or
\code{NULL} indices are not currently implemented.}

\item{...}{\link{DSArray} objects. For \code{arbind}, the \code{ncol} and
\code{nslice} of all objects must match, but the \code{nrow} may differ. For
\code{acbind}, the \code{nrow} and \code{nslice} of all objects must match,
but the \code{ncol} may differ.}

\item{drop}{Currently ignored}
}
\description{
The \code{DSArray} class provides compressed storage of 3-dimensional
arrays when the array has many duplicate slices. A basic array-like API is
provided for instantiating, subsetting, and combining DSArray objects.
}
\details{
Suppose we have a 3-dimensional array, \code{x}, with dimensions indexed by
\code{i} (rows), \code{j} (columns), and \code{k} (\emph{slices}). We refer
to \code{x[i, j, ]} as an \code{(i,j)}-slice (here
\code{length(i) == length(j) == 1}). For certain data it is the case that
many of the \code{(i,j)}-slices of \code{x} are repeated or duplicated
multiple times. These data can be more efficiently stored by retaining only
those unique \code{(i,j)}-slices of \code{x} and creating a map
between the original data and these unique \code{(i,j)}-slices. This is
what the DSArray class implements. Of course, a DSArray representation of
\code{x} is only worthwhile if \code{x} contains many such duplicate
\code{(i,j)}-slices.

The DSArray class was initially conceived for use as an element of a
\link[SummarizedExperiment]{Assays} object in the \code{assays} slot of a
\link[SummarizedExperiment]{SummarizedExperiment} object. Therefore \code{i}
indexes rows (features/ranges), \code{j} indexes columns (samples), and
\code{k} indexes slices. Importantly, the aim is to have the DSArray version
of \code{x} behave from the user's perspective just as if it were in its
"dense" form.
}
\section{Slots}{

\describe{
\item{\code{key}}{An integer matrix where the \eqn{(i, j)}-entry of the \code{key}
corresponds to the \eqn{i^{th}} row and \eqn{j^{th}} column of the original
3-dimensional "dense" array.}

\item{\code{val}}{A matrix storing the unique slices of the input array.}
}}
\section{Design and Internals}{

Let \code{x} be a 3-dimensional array and let \code{dsa} be its DSArray
representation. A duplicate \code{(i,j)}-slice of \code{x} is one such that
\code{identical(x[i1, j1, ], x[i2, j2, ])} returns \code{TRUE} with at
least one of \code{i1 != i2} or \code{j1 != j2}. \code{dsa} stores the
unique \code{(i,j)}-slices of \code{x} as a \link{matrix}
(\code{slot(dsa, "val")}) and an integer matrix (\code{slot(dsa, "map")})
mapping the \code{(i, j)}-slice of \code{x} to a row of
\code{slot(dsa, "val")}.

As noted above, the DSArray representation of \code{x} is only worthwhile if
\code{x} contains many duplicate \code{(i,j)}-slices since this ensures
that \code{nrow(val)} is much smaller than \code{nrow(x)}. Furthermore, the
DSArray representation of \code{x} becomes proportionally more efficient as
the number of slices (\code{dim(x)[3]}) increases. For a fixed
\code{nrow(x)}, the relative efficiency of \code{DSArray(x)} compared to
\code{x} increases linearly in the proportion of duplicate
\code{(i,j)}-slices. More specifically, the relative memory
usage of \code{DSArray(x)} compared to \code{x} is proportional to:
\code{4 / (dim(x)[3] * s) +
 sum(duplicated(apply(x, 3, I))) / (nrow(x) * ncol(x))} where \code{s = 4}
for \code{\link[base]{integer}} arrays and \code{s = 8} for
\code{\link[base]{numeric}} arrays. Note that this means if
\code{dim(x)[3] < 2} then \code{DSArray(x)} always uses more memory than
\code{x}.

The maximum number of rows of a DSArray object is currently
\code{.Machine$integer.max}, approximately 2.1 billion rows on a 64-bit
machine.
}

\section{Supported Types}{

R supports \code{\link[base]{logical}}, \code{\link[base]{integer}},
\code{\link[base]{double}} (often called \code{\link[base]{numeric}}),
\code{\link[base]{character}}, \code{\link[base]{complex}}, and
\code{\link[base]{raw}} arrays. The DSArray class currently supports all
these types except \code{\link[base]{complex}} and \code{\link[base]{raw}}.
}

\section{API and Supported Methods}{

It is intended that a DSArray object behaves much as if it were a
\link[base]{array} object. Common operations such arithmetic (e.g.,
\code{`+`}, \code{`*`}), comparison (e.g., \code{==}, \code{<}), and
mathematical transformations (e.g., \code{log()}, \code{sin()}) are all
supported; see \link{DSArray-utils} for a full list and details.

However, not all operations that are well-defined for \link[base]{array}
objects are currently implemented for DSArray objects (e.g., \code{mean()}).
I plan to implement these as needed, so if you come across one that you
would like to have, then please file a feature request at
\url{https://github.com/PeteHaitch/DSArray/issues}.
}
\author{
Peter Hickey
}
\seealso{
\code{\link{DSArray}}, \code{\link{DSArray-utils}}
}

